## 一 指针概述

指针是一种数据类型，其实质就是内存地址。在开发中如果要使用一些数据的内存地址，需要用一个变量来保存该地址，这个变量称为指针变量。  

```c
    int a = 0;
    printf("%p \n",&a);    		// &a 查看a的地址

    // *p 定义指针变量
    int *p = NULL;             	// p是变量名， int * 是指针类型
    p = &a;             		// 将a的地址赋值给p
    printf("%d \n",*p);			// p指向了a的地址，*p就是a的值

    // 通过指针间接修改变量的值
    *p = 100;
    printf("%d \n",*p); 
```

贴士：
- 在指针声明时，* 号表示所声明的变量为指针
- 在指针使用时，* 号表示操作指针所指向的内存空间
  - * 表示通过地址(指针变量的值)找到指针指向的内存，再操作内存
  - * 放在等号的左边赋值（给内存赋值，写内存）
  - * 放在等号的右边取值（从内存中取值，读内存）

## 二 指针一些常识

#### 2.1 sizeof()测量指针大小

使用sizeof()可以测量指针的大小，得到的总是：4或8，该值意义是指针变量指向存储地址的大小。
- 在32位平台，所有的指针（地址）都是32位(4字节)
- 在64位平台，所有的指针（地址）都是64位(8字节)

```c
    char *p;
    printf("sizeof(p) = %d\n", sizeof(p));
    printf("sizeof(double *) = %d\n", sizeof(double *));
```

#### 2.2 野指针和空指针

**空指针**：把NULL赋值给指针，表示此指针变量没有指向任何变量(空闲可用)。NULL指针并未指向任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。 
```c
    int *p = NULL;          // NULL是一个值为0的宏常量：#define NULL ((void *)0)
```

**野指针**：任意数值赋值给指针变量都没有意义（只要不越界即可，如64位8字节），因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。  

野指针产生条件：
- 指针在刚创建时不会成为NULL指针，其缺省值是随机的，这样就会产生野指针。所以建议在创建指针变量时就要初始化。
- 指针在free或delete后未赋值NULL，此时只是释放指针所指的内存，却没有杀死指针本身。所以建议在释放指针后设置指针为NULL。
- 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。


#### 2.3 万能指针 void *

void *指针可以指向任意变量的内存空间：
```c
	void *p = NULL;

	int a = 10;
	p = (void *)&a; //指向变量时，最好转换为void *

	//使用指针变量指向的内存时，转换为int *
	*( (int *)p ) = 11;
	printf("a = %d\n", a);           // 11
```

#### 2.4 const修饰的指针变量

在编辑程序时，指针作为函数参数，如果不想修改指针对应内存空间的值，需要使用const修饰指针数据类型：
```c
	int a = 100;
	int b = 200;

    //指向常量的指针：修饰*，指针指向内存区域不能修改，指针指向可以变
	const int * p1 = &a;    // 等价于int const *p1 = &a;
	p1 = &b;                // 错误方式：*p1 = 111;

    //指针常量：修饰p1，指针指向不能变，指针指向的内存可以修改
	int * const p2 = &a;
	*p2 = 222;              // 错误方式：p2 = &b;
```

## 三 指针与数组

数组地址其实就是首元素地址：
```c
    int arr[] = {1,2,3,4};

    // 二者值一致
    printf("%p\n", arr);
    printf("%p\n", &arr[0]);

    //a = 10; //err, 数组名只是常量，不能修改
```

如果数组的每个元素都是指针，那么该数组是指针数组。

## 四 指针与函数

#### 4.1 函数形参改变实参值

```c
#include <stdio.h>

void swap1(int x, int y){
	int tmp;
	tmp = x;
	x = y;
	y = tmp;
	printf("x = %d, y = %d\n", x, y);
}

void swap2(int *x, int *y){
	int tmp;
	tmp = *x;
	*x = *y;
	*y = tmp;
}

int main(){

    // 值传递
	int a = 3;
	int b = 5;
	swap1(a, b); 
	printf("a = %d, b = %d\n", a, b);

    // 地址传递
	a = 3;
	b = 5;
	swap2(&a, &b); 
	printf("a2 = %d, b2 = %d\n", a, b);

	return 0;
}
```

#### 4.2 数组名做函数参数
数组名做函数参数，函数的形参会退化为指针：
```c
#include <stdio.h>

void printArrary(int *a, int n)	{
	int i = 0;
	for (i = 0; i < n; i++)
	{
		printf("%d, ", a[i]);
	}
	printf("\n");
}

int main(){
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	int n = sizeof(a) / sizeof(a[0]);

	//数组名做函数参数
	printArrary(a, n); 
	return 0;
}
```

#### 4.3 指针做为函数的返回值

```c
#include <stdio.h>

int a = 10;

int *getA(){
	return &a;
}


int main(){
	*( getA() ) = 111;
	printf("a = %d\n", a);

	return 0;
}
```

## 五 多级指针

C语言允许有多级指针存在，二级指针就是指向一个一级指针变量地址的指针。  

```c
	int a = 10;
	int *p = &a; //一级指针
	*p = 100; //*p就是a

	int **q = &p;
	//*q就是p
	//**q就是a

	int ***t = &q;
	//*t就是q
	//**t就是p
	//***t就是a
```