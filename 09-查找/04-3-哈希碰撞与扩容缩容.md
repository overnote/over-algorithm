## 一 哈希冲突与解决方案

如果两个不同的 key，通过哈希函数计算出了相同的哈希值，这时候，哈希表桶中的对应索引位置就会出现多个数据，这种现象称为**哈希碰撞**，也称为**哈希冲突**（Hash Collision）。

哈希冲突常见的解决办法有两种：

-   **链地址法（Separate Chaining）**：桶中的元素都是一个链表，碰撞的元素都存储在链表的结点中
-   **开放地址法（Open Addressing）**：发生冲突后，继续寻找哈希表中新的散列地址存放，只要桶足够大，那么空的散列地址一定能找到
-   **公共溢出区法**：创建一个与当前哈希表结构一样的哈希表，冲突的数据都放置在该表中，也称呼该表为溢出表。查找时，先与哈希表对照，如果对照不相等，则去溢出表再次查找。在冲突数据较少时，溢出表的性能是非常高的。

贴士：Java 采用了链地址法解决哈希碰撞问题，但是在 Java8 中，如果 `桶的容量 >= 64`，且 `单向链表的结点数 > 8` 时，链表将转换为红黑树，当哈希表不再满足这 2 个条件时，则红黑树会重新转变为单向链表。

## 二 链地址法

### 2.1 装填因子

装填因子（Load Factor），也称呼为负载因子，其值为：`结点总数据量 / 哈希表桶长度`。

装填因子的值与哈希表的查找效率有关。

### 2.2 链地址法查询效率

链地址法实现简单，假设哈希表共计存储数据为 n，容量为 size，那么平均链表中的元素数目为：n / size，该值即是第二节中的装填因子 Load Factor。

最坏情况：即是将某个链表的所有元素查询了一遍，次数为：`1 + loadFactor`。

### 2.3 链地址法的扩容缩容

在使用链地址法时，哈希表虽然可以无限制插入新数据，但是随着数据量的增多，每个 index 对应的 bucket 会越来越长，会造成效率的严重降低。

在合适的情况下就需要对桶进行扩容，Java 中扩容的规则：

-   当装填因子超过 0.75 时，进行扩容：因为装填因子在 0.75 以下，性能较好
-   容量每次扩大为原来的 2 倍

注意：如果索引的运算公式使用的是取模，我们说过数组的容量最好是质数，那么此时扩容后也需要保证数组的容量的质数！

### 2.4 扩容后元素存放

扩容后，由于 size 该不安，对应的 index 也会改变，那么就需要对所有元素的 index 和对应的桶重新进行 put！！！！。

注意：扩容会导致计算索引值的时的 length 出现变化，对应的索引值也会可能出现变化，如果扩容两倍，结点的索引有两种情况：

-   保持不变
-   更改为了 新 index = 旧 index + 旧容量

一般的做法是遍历以前的结点，将结点直接移动到新的桶中，而不是每个 key 都要重新创建。

## 三 开放地址法详解（了解即可）

### 3.1 线性探测

假设有关键字合集：{12,67,56,16,25,37,22,29,15,47,48,34}，表长为 12，使用散列函数 `f(key)=key mod 12` 计算索引地址，当计算到 37 时，会发现与计算 25 得到的结果都是 1，则此时就需要为 37 寻找新的地址。寻找办法是按照这个公式再次查找 `f(37) = (f(37) + 1) mod 12`，值为 2，则将 37 存入下标为 2 的位置。依次类推。

上述的解决方案称为**线性探测**。但是这里还会产生新的问题：在不断+1 过程中遇到的位置都不是空位，即是一连串的填充单元！这种现象叫做聚集。聚集引发了严重的性能问题。

### 3.2 二次探测

针对聚集现象，我们想到的办法自然是优化探测的步长，以减少聚集的机会，例如：第一次探测 index+$1^2$，第二次探测 index+$2^2$。此种做法我们称为**二次探测**。

即使是二次探测，也依然会有问题，比如，连续插入的是 32-112-82-2-192 这样的数据，其累加时步长是相同的，也会造成步长不一样的聚集。

### 3.3 再哈希

聚集的最终解决方案是**再哈希（Re-Hashing）**，再哈希法是为了彻底消除聚集问题的方案：

-   二次探测的步长是固定的：1，4，9，16....
-   现在使用一种依赖关键字的探测序列，每个关键字都不一样。那么及时不同的关键字映射到了相同的数组下标，其使用的探测序列也不相同

从上看出，再哈希法其实就是把关键字使用另外一个哈希函数，获得的结果作为步长。

贴士：

-   再哈希函数其结果不能输出为 0，因为没有步长则探测变成了原地踏步。
-   再哈希函数也不能和之前的哈希函数一样，因为如果使用一样的哈希函数，其结果还是原来的位置

再哈希函数一般如下表示：

```
# stepSize 即步长。 constant是一个小于数组容量的质数
stepSize = constant - (key % constant)
```

贴士：利用线性探测时，删除元素操作切记不能将元素设置为空，因为下次探测会遇到空指针，推荐设置为类似-1 这样的不可能的值。

### 3.4 开放地址法总结

开放地址法的效率：发生冲突后取决于探测的长度，平均探测长度取决于装填因子，装填因子越大，探测长度也越大，由于装填因子为：`n / size`， n 的最大值只能是 size，即装填因子最大值也只能是 1。

探测序列 P 和装填因子 L 的关系：

-   查找成功：P = (1 + 1 / (1 - L)$^2$) / 2
-   查找失败：P = (1 + 1 / (1 - L)) / 2

总结：

-   装填因子是 1/2 时，成功的搜索需要 1.5 次比较，不成功的搜索需要 2.5 次
-   装填因子是 2/3 时，分别需要 2.0 次和 5.0 次比较
-   如果装填因子更大，则比较次数会非常大
-   应该使装填因子保持在 2/3 以下，最好在 1/2 以下。但是装填因子越低，给定数量的数据项会需要越多的空间
-   实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，速度上升

二次探测和再哈希法性能相当，比线性探测性能略好：

-   成功搜索：-log<sub>2</sub>(1-loadFactor)/loadFactor
-   搜索失败：1/(1-loadFactor)

总结：

-   当填充因子是 0.5 时，成功和不成功的查找平均需要 2 次比较
-   当填充因子是 2/3 时，分别需要 2.37 和 3.0 次比较
-   当填充因子是 0.8 时，分别需要 2.9 和 5.0 次
-   因此对于较高的填充因子，相比线性探测，二次探测和再哈希法是可以忍受的
