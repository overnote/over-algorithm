## 一 数据结构与算法

计算机中：算法是为了解决日常生活中一系列问题而诞生的运算步骤的描述。 

## 二 算法特性

- 输入：可以理解为参数，所以算法可以没有输入，也可以有多个输入
- 输出：算法必须有输出，没有输出，算法也就失去了意义
- 有穷性：算法运算完毕后必须结束，其步骤必须是有限的
- 确定性：算法的每个步骤都有明确的意义，在一定条件下，相同的输入只能有唯一结果
- 可行性/有效性：算法的每一步都必须是可行有效的，即每一步都能通过执行有限次数完成

## 三 函数的渐进增长

现在实现一个结果有两个算法：算法A与算法B，他们的输入规模都是n，算法A要做2n+3次操作，算法B要做3n+1次操作，两个算法谁更快？  

我们发现，一开始A算法计算次数很多，随着n的增长(大于2)，A算法计算次数比算法B越来越少。所以可以得出结论：算法A整体上比算法B好。  

输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总大于另一个函数，则称函数是渐进增长。  

```
函数的渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得所有的n>N,f(n)总是比g(n)大，那么f(n)的增长渐进快于g(n)。    
```

在上述案例中，随着n的增大，其实后续的+3，+1都已经不重要了，在很多算法中，随着n的增长，常熟的影响会越来越小，最高项的指数影响越来越大。所以判断一个算法的肖律时，更应该关注最高项的阶数。  

## 四 算法的时间复杂度

#### 4.1 时间复杂度定义

算法中，语句的总执行次数使用T(n)表示，即表示问题规模n的函数。  

通过分析T(n)与n变化的情况，可以得到算法的时间复杂度：T(n)= O(f(n))。随着n的增长，算法执行时间的增长率和f(n)的增长率相同，称为算法的渐进时间复杂度，简称时间复杂度。  

这样用O()来体现算法时间复杂度的记法，也称为大O记法。举例：O(1)称为常熟阶，O(n)称为线性阶，O(n<sup>2</sup>)称为平方阶。

一般情况下，T(n)增长最慢的算法为最优算法。  

#### 4.2 推导大O阶方法

常用的推导大O阶的方法：
- 用常数1取代运行时间中的所有加法常数
- 在修改后的运行次数函数中，只保留最高阶项
- 如果最高阶项目存在且不是1，则去除与这个项相乘的常数
- 得到结果就是大O阶  

分析算法的复杂度，最关键的是分析循环结构的运行情况。  

#### 4.3 线性阶

计算1,2,3....100之间内所有数的和：
```go
func main() {
    fmt.Println(sum1(100))
}

// 求和算法1
func sum1(n int) int{
    sum := 0
    i := 0
    for i = 1; i <= n; i++ {
         sum = sum + i              // 该具体步骤时间复杂度为O(1)
    }
    return sum
}

```

在上述算法中，算法的复杂度为O(n)，因为循环的代码需要执行n次。

#### 4.4 常数阶

4.3中的求和题目只是常规解法，数学家高斯在小时候在几分钟内给出了答案，他的思路如下：
```
1   +  2   +  3   +  ...  +  100
100 +  99  +  98  +  ...  +  1

结果：( 1 + 100) * 100 / 2
```
上述算法使用代码形式：
```go
// 求和算法2
func sum2(n int) int{
    sum := 0
    sum = ( 1 + n ) * n / 2;
    return sum
}
```

上述函数内部执行了三步运算f(n)=3，根据推导规则1，常数3改为1，且没有最高项，算法的时间复杂度为O(1)  

执行时间恒定的算法（不会随着n的变化而变化），我们成为常数阶。  

#### 4.5 对数阶

```go
func fn(n int) int{
    count := 1
    for {
        if count >= n {
            break;
        }
        count = count * 2
    }
    return count
}
```

由于每次count乘以2以后，距离n更近了一分，即有多少2相乘后大于n，则会退出循环，2<sup>x</sup>=n得到x = log<sub>2</sub>n。其时间复杂度为：O(logn)

#### 4.6 平方阶

循环的时间复杂度为O(n)，那么循环嵌套的复杂度如下所示为：O(m * n)
```go
func fn(m int, n int){
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            // 时间复杂度为O(1)的程序序列
        }
    }
}
```

总结：循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。  

再看一个例子：
```go

func fn(n int){
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            // 时间复杂度为O(1)的程序序列
        }
    }
}
```
上述算法总执行次数为： 
```
n + (n-1) + (n-2) + ... + 1 = n*(n+1)/2 = n<sup>2</sup>/2 + n/2
```
最终的时间复杂度为：O(n<sup>2</sup>)


#### 4.7 常见的时间复杂度

![](/images/local-07.png)

常用的时间复杂度顺序为：

![](/images/local-08.png)

但是像n的三次方以后，过大的n会让结果变得不现实，程序的运行效率极低，已经很不现实了。

## 五 最坏情况与平均情况  

比如查询n个随机数数组中最小数，最好第一个元素就是，那么时间复杂度为O(1)，如果很不幸数组的最后一个元素才是，那么时间复杂度是O(n)。  

对算法的分析，一种方法是计算所有情况的平均值，称为平均时间复杂度(上述案例的n/2)，一种方法是计算最坏情况下的复杂度。一般都会使用最坏复杂度。  

通过空间能够换取时间上的便利，比如判断某个年份是否是闰年，我们可以书写一个算法，这个算法每次给出年份都要进行计算，但是我们也可以将所有的年份书写为一个键值对，是闰年的值为1，不是的值为0，这样判断是否是闰年直接查看键值对结果即可，但是相应的，我们需要这个键值对的额外存储空间。  

算法的空间复杂度公式：
```
S(n) = O(f(n))      # n为问题规模，f(n)为n锁占存储空间的函数
```

贴士：如果算法执行时所需的辅助空间相遇于输入的数据量来说是个常数，那么称此算法为原地工作，空间复杂度为O(1)。  

通常我们说算法的复杂度是指时间复杂度。 